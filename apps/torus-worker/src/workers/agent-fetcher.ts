import type { LastBlock, Proposal, SS58Address, PermissionContract, PermissionId } from "@torus-network/sdk";
import {
  checkSS58,
  CONSTANTS,
  queryAgents,
  queryLastBlock,
  queryWhitelist,
  queryPermissions,
} from "@torus-network/sdk";
import { BasicLogger } from "@torus-network/torus-utils/logger";
import { tryAsync } from "@torus-network/torus-utils/try-catch";
import { match } from "rustie";
import type { WorkerProps } from "../common";
import {
  agentApplicationToApplication,
  agentProposalToProposal,
  getApplications,
  getProposals,
  getProposalStatus,
  normalizeApplicationValue,
  sleep,
} from "../common";
import type { NewApplication, NewProposal, NewPermission, NewPermissionDetails, NewPermissionEmissionScope, NewEmissionStream, NewEnforcementAuthority } from "../db";
import {
  queryProposalsDB,
  SubspaceAgentToDatabase,
  upsertAgentData,
  upsertProposal,
  upsertWhitelistApplication,
  upsertPermissions,
} from "../db";

const log = BasicLogger.create({ name: "agent-fetcher" });

// Constants for error handling configuration
const retryDelay = CONSTANTS.TIME.BLOCK_TIME_MILLISECONDS;

/**
 * Transforms a blockchain permission contract to database format
 */
function permissionContractToDatabase(
  permissionId: PermissionId,
  contract: PermissionContract,
): {
  permission: NewPermission;
  details: NewPermissionDetails;
  emissionScope?: NewPermissionEmissionScope;
  emissionStream?: NewEmissionStream;
  enforcementAuthorities?: NewEnforcementAuthority[];
} | null {
  const permission: NewPermission = {
    permission_id: permissionId,
  };

  // Only process emission permissions, skip curator permissions
  const isEmissionPermission = match(contract.scope)({
    Emission: () => true,
    Curator: () => false,
  });

  if (!isEmissionPermission) {
    return null; // Skip curator permissions
  }

  const duration = match(contract.duration)({
    Indefinite: () => "0",
    UntilBlock: (block) => block.toString(),
  });

  const parentId = match(contract.parent)({
    Some: (id) => id,
    None: () => null,
  });

  const details: NewPermissionDetails = {
    permission_id: permissionId,
    grantor_key: contract.grantor,
    grantee_key: contract.grantee,
    scope: "EMISSION" as const,
    duration,
    revocation: 0, // TODO: Map revocation terms properly
    // last_execution: skipped for now due to date conversion issues
    execution_count: contract.executionCount.toString(),
    parent_id: parentId,
    constraint_id: null, // Will be set later when constraints are processed
  };

  let emissionScope: NewPermissionEmissionScope | undefined;
  let emissionStream: NewEmissionStream | undefined;
  let enforcementAuthorities: NewEnforcementAuthority[] | undefined;

  // Handle emission scope - we need to create emissionStream first, then emissionScope
  // Only process Emission permissions with Streams allocation
  const shouldSkip = match(contract.scope)({
    Emission: (emission) => {
      return match(emission.allocation)({
        Streams: () => false, // Don't skip stream-based
        FixedAmount: () => true, // Skip fixed amount
      });
    },
    Curator: () => true, // Skip curator permissions
  });

  if (shouldSkip) {
    return null; // Skip this permission entirely
  }

  // At this point we know it's an Emission permission with Streams allocation
  match(contract.scope)({
    Emission: (emission) => {
      // First create the emissionStream record
      emissionStream = {
        permission_id: permissionId,
        // streams_uuid will be auto-generated by database
      };

      match(emission.allocation)({
        Streams: (streams) => {
          const firstStream = Array.from(streams.entries())[0];
          if (firstStream) {
            const [_streamId, _percentage] = firstStream;
            
            // Map distribution type
            const distributionType = match(emission.distribution)({
              Manual: () => "MANUAL" as const,
              Automatic: () => "AUTOMATIC" as const,
              AtBlock: () => "AT_BLOCK" as const,
              Interval: () => "INTERVAL" as const,
            });

            emissionScope = {
              permission_id: permissionId,
              streams_uuid: "placeholder", // Will be replaced with actual UUID in upsertPermissions
              distribution_type: distributionType,
              distribution_info: null, // TODO: Store distribution details if needed
              accumulating: emission.accumulating,
            };
          }
        },
        FixedAmount: () => {
          // This case should never be reached due to shouldSkip check above
        },
      });
    },
    Curator: () => {
      // This case should never be reached due to shouldSkip check above
    },
  });

  // Handle enforcement authorities
  match(contract.enforcement)({
    ControlledBy: (controlled) => {
      enforcementAuthorities = controlled.controllers.map(
        (controller: SS58Address): NewEnforcementAuthority => ({
          permission_id: permissionId,
          ss58_address: controller,
        })
      );
    },
    None: () => {
      // No enforcement authorities
    },
  });

  return {
    permission,
    details,
    emissionScope,
    emissionStream,
    enforcementAuthorities,
  };
}

/**
 * Synchronizes on-chain agent data to the database for a given block height.
 * Handles whitelist status checks and transforms blockchain data to database format.
 *
 * @param lastBlock - Contains blockchain API instance frozen at a specific block height
 */
export async function runAgentFetch(lastBlock: LastBlock) {
  const startTime = new Date();
  const api = lastBlock.apiAtBlock;
  const blockNumber = lastBlock.blockNumber;

  log.info(`Block ${blockNumber}: running agent fetch`);

  const whitelistRes = await tryAsync(queryWhitelist(api));
  if (log.ifResultIsErr(whitelistRes)) return;
  const [_whitelistErr, whitelist] = whitelistRes;

  const agentsRes = await tryAsync(queryAgents(api));
  if (log.ifResultIsErr(agentsRes)) return;
  const [_agentsErr, agentsMap] = agentsRes;

  const whitelistSet = new Set(whitelist);
  const isWhitelisted = (addr: SS58Address) => whitelistSet.has(addr);
  const agents = [...agentsMap.values()];
  const agentsData = agents.map((agent) =>
    SubspaceAgentToDatabase(
      agent,
      blockNumber,
      isWhitelisted(checkSS58(agent.key)),
    ),
  );

  log.info(`Block ${blockNumber}: upserting ${agents.length} agents`);

  const upserAgentDataRes = await tryAsync(upsertAgentData(agentsData));
  if (log.ifResultIsErr(upserAgentDataRes)) return;

  const timeDelta = new Date().getTime() - startTime.getTime();
  log.info(
    `Block ${blockNumber}: agent data upserted in ${timeDelta / 1000} seconds`,
  );
}

/**
 * Captures all whitelist applications from the blockchain at a specific block height.
 * This always processes the complete set of applications to maintain full audit history.
 *
 * @param lastBlock - Contains blockchain API instance frozen at a specific block height
 */
export async function runApplicationsFetch(lastBlock: LastBlock) {
  const lastBlockNumber = lastBlock.blockNumber;
  log.info(`Block ${lastBlockNumber}: running applications fetch`);

  const applicationsRes = await tryAsync(
    getApplications(lastBlock.apiAtBlock, (_) => true),
  );
  if (log.ifResultIsErr(applicationsRes)) return;
  const [_applicationsErr, applications] = applicationsRes;

  const applicationsMap = new Map(Object.entries(applications));
  const dbApplications: NewApplication[] = [];
  applicationsMap.forEach((value, _) => {
    dbApplications.push(agentApplicationToApplication(value));
  });

  log.info(
    `Block ${lastBlockNumber}: upserting ${dbApplications.length} applications`,
  );

  const upsertWhitelistApplicationRes = await tryAsync(
    upsertWhitelistApplication(dbApplications),
  );
  if (log.ifResultIsErr(upsertWhitelistApplicationRes)) return;
  log.info(`Block ${lastBlockNumber}: applications upserted`);
}

/**
 * Performs differential synchronization of blockchain proposals to database.
 * Optimizes database operations by only processing proposals that are new or have
 * changed status since the last sync.
 *
 * @param lastBlock - Contains blockchain API instance frozen at a specific block height
 */
export async function runProposalsFetch(lastBlock: LastBlock) {
  const lastBlockNumber = lastBlock.blockNumber;
  log.info(`Block ${lastBlockNumber}: running proposals fetch`);

  const queryProposalsRes = await tryAsync(queryProposalsDB());
  if (log.ifResultIsErr(queryProposalsRes)) return;
  const [_queryProposalsError, queryProposalsResult] = queryProposalsRes;

  const savedProposalsMap = new Map(
    queryProposalsResult.map((proposal) => [proposal.id, proposal]),
  );
  const isProposalToInsert = (a: Proposal) => {
    const existingProposal = savedProposalsMap.get(a.id);
    const isNewProposal = !existingProposal;
    const hasStatusChanged =
      !isNewProposal &&
      getProposalStatus(a) !==
        normalizeApplicationValue(existingProposal.status);
    return isNewProposal || hasStatusChanged;
  };

  const getProrposalsRes = await tryAsync(
    getProposals(lastBlock.apiAtBlock, isProposalToInsert),
  );
  if (log.ifResultIsErr(getProrposalsRes)) return;
  const [_getProposalsError, proposalsResult] = getProrposalsRes;

  const proposalsMap = new Map(Object.entries(proposalsResult));
  const dbProposals: NewProposal[] = [];
  proposalsMap.forEach((value, _) => {
    dbProposals.push(agentProposalToProposal(value));
  });

  log.info(
    `Block ${lastBlockNumber}: upserting ${dbProposals.length} proposals`,
  );

  const upsertProposalRes = await tryAsync(upsertProposal(dbProposals));
  if (log.ifResultIsErr(upsertProposalRes)) return;

  log.info(`Block ${lastBlockNumber}: proposals upserted`);
}

/**
 * Fetches all permissions from the blockchain and stores them in the database.
 * This captures the complete state of all permissions at a specific block height.
 *
 * @param lastBlock - Contains blockchain API instance frozen at a specific block height
 */
export async function runPermissionsFetch(lastBlock: LastBlock) {
  const lastBlockNumber = lastBlock.blockNumber;
  log.info(`Block ${lastBlockNumber}: running permissions fetch`);

  const permissionsQueryResult = await queryPermissions(lastBlock.apiAtBlock);
  const [permissionsMapErr, permissionsMap] = permissionsQueryResult;
  if (permissionsMapErr) {
    log.error(`Block ${lastBlockNumber}: queryPermissions failed:`, permissionsMapErr);
    return;
  }

  log.info(`Block ${lastBlockNumber}: found ${permissionsMap.size} permissions from blockchain`);

  const permissionsData: {
    permission: NewPermission;
    details: NewPermissionDetails;
    emissionScope?: NewPermissionEmissionScope;
    emissionStream?: NewEmissionStream;
    enforcementAuthorities?: NewEnforcementAuthority[];
  }[] = [];

  // Transform each permission to database format  
  for (const [permissionId, contract] of permissionsMap.entries()) {
    try {
      const permissionData = permissionContractToDatabase(permissionId, contract);
      if (permissionData) {
        permissionsData.push(permissionData);
        log.info(`Block ${lastBlockNumber}: added emission permission ${permissionId} to batch`);
      } else {
        log.info(`Block ${lastBlockNumber}: skipped curator permission ${permissionId}`);
      }
    } catch (error) {
      log.error(`Failed to transform permission ${permissionId}:`, error);
      continue; // Skip this permission but continue with others
    }
  }

  log.info(
    `Block ${lastBlockNumber}: upserting ${permissionsData.length} permissions`,
  );

  const upsertPermissionsRes = await tryAsync(upsertPermissions(permissionsData));
  if (log.ifResultIsErr(upsertPermissionsRes)) return;

  log.info(`Block ${lastBlockNumber}: permissions upserted`);
}

/**
 * Blockchain data synchronization in an infinite loop.
 * Processes each new block once, skips already processed blocks, and handles
 * all errors internally to ensure the synchronization process never terminates.
 *
 * @param props - Contains API connection and state for tracking the last processed block
 */
export async function agentFetcherWorker(props: WorkerProps) {
  while (true) {
    const fetchWorkerRes = await tryAsync(
      (async () => {
        // Get latest block information with error logging
        const queryLastBlockRes = await tryAsync(queryLastBlock(props.api));
        if (log.ifResultIsErr(queryLastBlockRes)) {
          await sleep(CONSTANTS.TIME.BLOCK_TIME_MILLISECONDS);
          return;
        }
        const [_queryLastBlockError, lastBlock] = queryLastBlockRes;

        const lastBlockNumber = lastBlock.blockNumber;

        // Check if the last queried block is a new block
        if (props.lastBlock.blockNumber === lastBlockNumber) {
          log.info(
            `Block ${props.lastBlock.blockNumber}: already processed, skipping`,
          );
          await sleep(CONSTANTS.TIME.BLOCK_TIME_MILLISECONDS);
          return;
        }
        props.lastBlock = lastBlock;

        log.info(`Block ${lastBlockNumber}: processing`);

        await runAgentFetch(lastBlock);
        await runApplicationsFetch(lastBlock);
        await runProposalsFetch(lastBlock);
        await runPermissionsFetch(lastBlock);
      })(),
    );
    if (log.ifResultIsErr(fetchWorkerRes)) {
      await sleep(retryDelay);
    }
  }
}
